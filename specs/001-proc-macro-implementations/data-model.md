# Data Model: Proc-Macro Workshop Implementations

**Feature**: 001-proc-macro-implementations  
**Date**: 2025-12-25

## Overview

This document describes the key data structures used during macro parsing and the types generated by each macro. Procedural macros transform input tokens into output tokens; this model captures the intermediate representations.

---

## Common Structures (All Projects)

### Input: `proc_macro::TokenStream`

The raw token stream provided by the compiler to every proc macro.

### Parsed Input: `syn::DeriveInput` (for derive macros)

```text
DeriveInput
├── attrs: Vec<Attribute>      # Outer attributes like #[builder(...)]
├── vis: Visibility            # pub, pub(crate), etc.
├── ident: Ident               # Name of the struct/enum
├── generics: Generics         # <T, U> and where clauses
└── data: Data                 # Struct fields or enum variants
    ├── DataStruct { fields: Fields }
    ├── DataEnum { variants: Vec<Variant> }
    └── DataUnion { ... }
```

### Output: `proc_macro2::TokenStream`

The generated code as tokens, converted to `proc_macro::TokenStream` for return.

---

## Builder Project

### Parsed Field Information

```text
BuilderField
├── ident: Ident               # Field name (e.g., "executable")
├── ty: Type                   # Field type (e.g., String, Vec<String>)
├── is_optional: bool          # True if type is Option<T>
├── inner_type: Option<Type>   # T if Option<T> or Vec<T>
├── each_name: Option<String>  # Value from #[builder(each = "...")]
└── span: Span                 # For error reporting
```

### Generated Types

```text
CommandBuilder (generated struct)
├── executable: Option<String>       # All fields wrapped in Option
├── args: Option<Vec<String>>        # Even Vec fields
├── env: Option<Vec<String>>
└── current_dir: Option<String>

impl Command
├── fn builder() -> CommandBuilder   # Entry point

impl CommandBuilder
├── fn executable(&mut self, value: String) -> &mut Self
├── fn arg(&mut self, value: String) -> &mut Self     # From #[builder(each)]
├── fn args(&mut self, value: Vec<String>) -> &mut Self
├── fn build(&mut self) -> Result<Command, Box<dyn Error>>
```

---

## CustomDebug Project

### Parsed Field Information

```text
DebugField
├── ident: Ident               # Field name
├── ty: Type                   # Field type
├── format: Option<String>     # Custom format from #[debug = "..."]
├── is_phantom: bool           # True if type is PhantomData<T>
└── span: Span
```

### Parsed Struct Information

```text
DebugInput
├── ident: Ident               # Struct name
├── generics: Generics         # Generic parameters
├── fields: Vec<DebugField>    # All struct fields
├── custom_bound: Option<String>  # From #[debug(bound = "...")]
└── inferred_bounds: Vec<WherePredicate>  # Computed from field types
```

### Generated Implementation

```text
impl<T: Debug, ...> Debug for Wrapper<T, ...>
where
    [inferred or custom bounds]
{
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.debug_struct("Wrapper")
            .field("name", &self.name)
            .field("bitmask", &format_args!("0b{:08b}", self.bitmask))
            .finish()
    }
}
```

---

## Seq Project

### Parsed Header

```text
SeqInput
├── var: Ident                 # Loop variable (e.g., N)
├── start: LitInt              # Range start (inclusive)
├── end: LitInt                # Range end
├── inclusive: bool            # True for ..= ranges
└── body: TokenStream          # Everything inside { ... }
```

### Repeat Section

```text
RepeatSection
├── tokens: TokenStream        # Content inside #(...)* 
├── start_span: Span           # For error messages
└── end_span: Span
```

### Token Pasting Target

```text
PasteTarget
├── prefix: Ident              # The identifier before ~
├── variable: Ident            # The N in Cpu~N
├── span: Span                 # Combined span
```

### Generated Output

For `seq!(N in 0..3 { struct Foo~N; })`:
```rust
struct Foo0;
struct Foo1;
struct Foo2;
```

---

## Sorted Project

### Enum Validation

```text
SortedEnum
├── ident: Ident               # Enum name
├── variants: Vec<Ident>       # Variant names in source order
└── span: Span                 # For "sorted only works on enum" error
```

### Match Expression Validation

```text
SortedMatch
├── arms: Vec<MatchArm>        # Match arms in source order
├── arm_names: Vec<String>     # Extracted pattern names for sorting
└── sorted_attr_span: Span     # Span of the #[sorted] attribute
```

### Error Information

```text
SortedError
├── kind: ErrorKind
│   ├── NotAnEnum              # #[sorted] on non-enum
│   ├── OutOfOrder             # Variant/arm not in alphabetical order
│   └── UnrecognizedPattern    # Match pattern we can't extract name from
├── found: String              # The out-of-order name
├── expected_before: String    # What it should come before
└── span: Span                 # Where to point the error
```

---

## Bitfield Project

### Specifier Trait

```text
trait Specifier
├── const BITS: usize          # Number of bits this type occupies
└── type Storage               # u8, u16, u32, or u64 for value representation
```

### B1-B64 Types

```text
enum B1 {}                     # Uninhabited marker type
impl Specifier for B1
├── BITS = 1
└── Storage = u8

enum B64 {}
impl Specifier for B64
├── BITS = 64
└── Storage = u64
```

### Parsed Bitfield Struct

```text
BitfieldInput
├── ident: Ident               # Struct name (e.g., MyFourBytes)
├── vis: Visibility            # For generated impl
├── fields: Vec<BitfieldField>
└── total_bits: usize          # Sum of all field BITS (validated % 8 == 0)

BitfieldField
├── ident: Ident               # Field name (e.g., "a", "b", "c")
├── ty: Type                   # Specifier type (e.g., B1, B3, TriggerMode)
├── bits_attr: Option<usize>   # From #[bits = N] if present
├── bit_offset: usize          # Computed starting bit position
└── span: Span
```

### Generated Bitfield Struct

```text
struct MyFourBytes
├── data: [u8; N]              # N = total_bits / 8

impl MyFourBytes
├── fn new() -> Self           # Initialize all bits to 0
├── fn get_a(&self) -> u8      # Getter for field a
├── fn set_a(&mut self, value: u8)  # Setter for field a
├── fn get_d(&self) -> u32     # Getter uses appropriate integer size
└── fn set_d(&mut self, value: u32)
```

### Enum Specifier (BitfieldSpecifier derive)

```text
#[derive(BitfieldSpecifier)]
enum TriggerMode
├── Edge = 0
└── Level = 1

impl Specifier for TriggerMode
├── BITS = 1                   # ceil(log2(variant_count))
└── Storage = u8

impl TriggerMode
├── fn from_bits(bits: u8) -> Self
└── fn into_bits(self) -> u8
```

---

## Relationship Diagram

```text
┌─────────────────────────────────────────────────────────────────┐
│                        Compiler                                  │
│  TokenStream (input) ──────────────────────> TokenStream (output)│
└───────────────────────────────┬─────────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    │    syn::parse()       │
                    └───────────┬───────────┘
                                │
            ┌───────────────────┼───────────────────┐
            ▼                   ▼                   ▼
    ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
    │  DeriveInput  │   │  Custom Parse │   │   ItemFn      │
    │  (builder,    │   │  (seq)        │   │   (sorted)    │
    │   debug,      │   └───────┬───────┘   └───────┬───────┘
    │   bitfield)   │           │                   │
    └───────┬───────┘           │                   │
            │                   │                   │
            ▼                   ▼                   ▼
    ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
    │ Extract Info  │   │ Token Manip   │   │ VisitMut      │
    │ (fields,      │   │ (paste, rep)  │   │ (find match)  │
    │  generics)    │   └───────┬───────┘   └───────┬───────┘
    └───────┬───────┘           │                   │
            │                   │                   │
            ▼                   ▼                   ▼
    ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
    │ quote! { }    │   │ Build Tokens  │   │ Emit Errors   │
    │ Generate Code │   │ Manually      │   │ or Pass-thru  │
    └───────┬───────┘   └───────┬───────┘   └───────┬───────┘
            │                   │                   │
            └───────────────────┴───────────────────┘
                                │
                    ┌───────────┴───────────┐
                    │ proc_macro::TokenStream │
                    │ (returned to compiler) │
                    └───────────────────────┘
```

