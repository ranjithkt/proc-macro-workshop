# Quickstart: Proc-Macro Workshop Implementations

**Feature**: 001-proc-macro-implementations  
**Date**: 2025-12-25

## Prerequisites

- Rust stable (1.70+ recommended)
- `cargo-expand` for debugging: `cargo install cargo-expand`

## Project Structure Overview

```
proc-macro-workshop/
├── builder/       # P1: Derive macro for builder pattern
├── debug/         # P2: Derive macro for custom Debug
├── seq/           # P3: Function-like macro for sequences
├── sorted/        # P4: Attribute macro for sorting validation
├── bitfield/      # P5: Attribute macro for bitfield structs
│   └── impl/      # (proc-macro crate for bitfield)
├── main.rs        # Scratch file for cargo expand
└── Cargo.toml     # Workspace root
```

## Implementation Order

Follow this order (matches workshop recommendations):

1. **builder** → Fundamentals (parsing, code gen, attributes)
2. **debug** → Generics and trait bounds
3. **seq** → Custom syntax parsing
4. **sorted** → Compile-time validation, visitor pattern
5. **bitfield** → Multi-macro coordination, advanced tricks

## Quick Test Commands

### Test a Single Project

```bash
cd builder  # or debug, seq, sorted, bitfield
cargo test
```

### Test All Projects

```bash
# From workspace root
cargo test --workspace
```

### Run Specific Test

```bash
cd builder
cargo test 01  # Runs tests matching "01"
```

## Development Workflow

### 1. Enable Tests Incrementally

Each project has `tests/progress.rs` with commented tests:

```rust
// tests/progress.rs
#[test]
fn tests() {
    let t = trybuild::TestCases::new();
    t.pass("tests/01-parse.rs");
    //t.pass("tests/02-create-builder.rs");  // Uncomment when ready
    //t.pass("tests/03-call-setters.rs");
    // ...
}
```

Uncomment one test at a time, implement until it passes, then move to the next.

### 2. Read Test File Comments

Each test file has implementation hints:

```rust
// tests/01-parse.rs
// This test looks for a derive macro with the right name to exist. For now the
// test doesn't require any specific code to be generated by the macro, so
// returning an empty TokenStream should be sufficient.
//
// Before moving on, have your derive macro parse the macro input as a
// syn::DeriveInput syntax tree.
```

### 3. Debug with cargo expand

Edit `main.rs` in workspace root with test code:

```rust
use derive_builder::Builder;

#[derive(Builder)]
pub struct Command {
    executable: String,
}

fn main() {}
```

Then run:

```bash
cargo expand
```

### 4. Debug with eprintln!

In your macro:

```rust
#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    eprintln!("INPUT: {:#?}", input);  // Requires syn/extra-traits
    // ...
}
```

Run `cargo test` or `cargo check` to see output.

## Adding Dependencies

### Minimal Setup (all projects)

```toml
# In each project's Cargo.toml
[lib]
proc-macro = true

[dependencies]
syn = { version = "2", features = ["derive", "parsing"] }
quote = "1"
proc-macro2 = "1"
```

### With darling (builder, debug, bitfield)

```toml
[dependencies]
darling = "0.20"
```

### With proc-macro-error2 (sorted, bitfield)

```toml
[dependencies]
proc-macro-error2 = "2"
```

### Full features for sorted

```toml
[dependencies]
syn = { version = "2", features = ["full", "parsing", "visit-mut"] }
```

## Common Patterns

### Basic Derive Macro

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyMacro)]
pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    
    let expanded = quote! {
        impl #name {
            pub fn hello() { println!("Hello from {}", stringify!(#name)); }
        }
    };
    
    expanded.into()
}
```

### Error Handling

```rust
fn derive_impl(input: DeriveInput) -> Result<TokenStream, syn::Error> {
    // Return Err(syn::Error::new(span, "message")) for errors
    Ok(quote!{ /* ... */ }.into())
}

#[proc_macro_derive(MyMacro)]
pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    derive_impl(input)
        .unwrap_or_else(|e| e.to_compile_error().into())
}
```

### Attribute Macro

```rust
#[proc_macro_attribute]
pub fn my_attr(args: TokenStream, input: TokenStream) -> TokenStream {
    // args: tokens inside the attribute #[my_attr(these tokens)]
    // input: the item the attribute is on
    input  // Return input unchanged, or modified
}
```

## Validation Checklist

Before considering a project complete:

- [ ] All tests in `tests/progress.rs` uncommented
- [ ] `cargo test` passes with no warnings
- [ ] `cargo clippy --all-targets` clean
- [ ] `cargo doc` builds without warnings
- [ ] `cargo expand` shows correct output

## Troubleshooting

### "can't find crate"

Make sure `proc-macro = true` is in `Cargo.toml`:

```toml
[lib]
proc-macro = true
```

### "expected TokenStream"

Use `.into()` to convert:

```rust
let tokens: proc_macro2::TokenStream = quote!{ ... };
tokens.into()  // Convert to proc_macro::TokenStream
```

### Error spans point to wrong location

Use `Span::call_site()` for generated code, original spans for user code:

```rust
let name = Ident::new("generated_name", Span::call_site());
let user_field = &field.ident;  // Keeps original span
```

### "duplicate lang item"

You may have duplicate `syn` versions. Check:

```bash
cargo tree -d | grep syn
```

Use only syn 2.x, avoid crates depending on syn 1.x.

## Resources

- [syn documentation](https://docs.rs/syn/2/)
- [quote documentation](https://docs.rs/quote/1/)
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [Procedural Macros Workshop README](../README.md)

